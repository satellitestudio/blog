<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>OpenStreetMap Haiku</title>
  <link rel="stylesheet" href="../../index.css">
  <link rel="stylesheet" href="../../lib/prism.css">
</head>
<body>
  <a id="logo" href="//satellitestud.io">
    <svg width="150px" viewBox="0 0 183 50" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
      <desc id="logoDesc">Satellite Studio Logo</desc>
        <path d="M34.767,1.980 C33.655,3.539 33,5.441 33,7.5 C33,12.747 37.253,17 42.5,17 C44.558,17 46.464,16.345 48.020,15.233 C49.294,18.233 50,21.534 50,25 C50,38.807 38.807,50 25,50 C11.192,50 0,38.807 0,25 C0,11.192 11.193,0 25,0 C28.466,0 31.767,0.705 34.767,1.980 Z"></path>
        <path d="M77.488,18.616 C79.44,18.616 81.232,19.576 82.256,21.176 L80.144,23.032 C79.344,22.008 78.352,21.56 77.328,21.56 C76.496,21.56 75.728,22.104 75.728,23.16 C75.728,24.312 76.944,24.824 78.608,25.464 C80.784,26.296 83.12,27.256 83.12,30.136 C83.12,32.92 80.976,35.256 77.52,35.256 C74.192,35.256 72.112,32.952 71.28,30.936 L74.096,29.4 C74.736,30.84 75.856,32.312 77.648,32.312 C78.928,32.312 79.824,31.672 79.824,30.2 C79.824,28.792 77.872,28.408 75.984,27.608 C74.128,26.84 72.528,25.656 72.528,23.192 C72.528,20.696 74.576,18.616 77.488,18.616 Z M85.68,30.36 C85.68,27.032 88.528,25.08 92.656,25.08 L95.44,25.08 L95.44,24.376 C95.44,22.36 94,21.56 92.304,21.56 C90.992,21.56 89.84,22.264 89.296,23.704 L86.256,23.064 C86.928,20.344 89.232,18.616 92.336,18.616 C96.08,18.616 98.768,20.248 98.768,24.984 L98.768,35 L95.952,35 L95.632,32.888 C94.576,34.36 92.912,35.256 90.64,35.256 C87.952,35.256 85.68,33.72 85.68,30.36 Z M89.2,30.36 C89.2,31.448 89.808,32.312 91.216,32.312 C93.264,32.312 95.44,31 95.44,28.216 L95.44,27.864 L92.528,27.864 C90.48,27.864 89.2,28.824 89.2,30.36 Z M101.296,21.816 L101.296,18.872 L103.984,18.872 L103.984,14.424 L107.312,12.344 L107.312,18.872 L111.504,18.872 L111.504,21.816 L107.312,21.816 L107.312,29.688 C107.312,31.512 107.984,32.312 109.456,32.312 C110.032,32.312 110.416,32.216 110.992,31.864 L111.856,34.68 C110.992,35.096 110.16,35.256 109.264,35.256 C106.224,35.256 103.984,33.464 103.984,29.496 L103.984,21.816 L101.296,21.816 Z M121.648,21.56 C119.44,21.56 118.064,23.064 117.712,25.08 L125.552,25.08 C125.264,23.288 124.048,21.56 121.648,21.56 Z M129.072,26.424 L129.072,27.864 L117.648,27.864 C117.648,30.232 119.024,32.312 121.648,32.312 C123.376,32.312 125.04,31.352 125.872,29.592 L128.72,30.712 C127.152,33.752 125.328,35.256 121.648,35.256 C116.336,35.256 114.128,30.776 114.128,26.936 C114.128,23.096 116.336,18.616 121.648,18.616 C126.8,18.616 129.072,22.808 129.072,26.424 Z M132.688,12.344 L136.016,12.344 L136.016,35 L132.688,35 L132.688,12.344 Z M140.368,12.344 L143.696,12.344 L143.696,35 L140.368,35 L140.368,12.344 Z M147.248,14.328 C147.248,13.048 148.24,11.992 149.552,11.992 C150.864,11.992 151.856,13.048 151.856,14.328 C151.856,15.608 150.864,16.6 149.552,16.6 C148.24,16.6 147.248,15.608 147.248,14.328 Z M147.888,18.872 L151.216,18.872 L151.216,35 L147.888,35 L147.888,18.872 Z M154.576,21.816 L154.576,18.872 L157.264,18.872 L157.264,14.424 L160.592,12.344 L160.592,18.872 L164.784,18.872 L164.784,21.816 L160.592,21.816 L160.592,29.688 C160.592,31.512 161.264,32.312 162.736,32.312 C163.312,32.312 163.696,32.216 164.272,31.864 L165.136,34.68 C164.272,35.096 163.44,35.256 162.544,35.256 C159.504,35.256 157.264,33.464 157.264,29.496 L157.264,21.816 L154.576,21.816 Z M174.928,21.56 C172.72,21.56 171.344,23.064 170.992,25.08 L178.832,25.08 C178.544,23.288 177.328,21.56 174.928,21.56 Z M182.352,26.424 L182.352,27.864 L170.928,27.864 C170.928,30.232 172.304,32.312 174.928,32.312 C176.656,32.312 178.32,31.352 179.152,29.592 L182,30.712 C180.432,33.752 178.608,35.256 174.928,35.256 C169.616,35.256 167.408,30.776 167.408,26.936 C167.408,23.096 169.616,18.616 174.928,18.616 C180.08,18.616 182.352,22.808 182.352,26.424 Z"></path>
    </svg>
  </a>

  <article>
   
    <h1>OpenStreetMap Haiku:<br>Using OSM and Overpass<br> for generative poetry</h1>


    <p>Some corner of London, last Monday, around 11am:</p>

    <cite>
      Wet to the bone<br>
      Looking at you from the 4th floor<br>
      Is it too early for a beer?
    </cite>

    <p>
      Same place, more random poetry:
    </p>

    <cite>
      A couple getting a loan<br>
      Yawns in the classroom<br>
      A train underneath
    </cite>

    <p>
      Or maybe, a few miles from there:
    </p>

    <cite>
      On the water’s surface<br>
      Going to work<br>
      Flipping burgers
    </cite>

    <figure>
      <video autoplay loop muted playsinline>
        <source src="osm-haiku.webm" type="video/webm">
      </video>
    </figure>

    <hr />

    <p>
      Here's what's happening: we automated making haikus about places. Looking at every aspect of the surroundings of a point, we can generate a poem about any place in the world. The result is sometimes fun, often weird, most of the time pretty terrible. Also probably horrifying for haiku purists (sorry). Go ahead and <a href="https://satellitestud.io/osm-haiku/app/">give it a try</a>.
    </p>

    <h2>But, why ?</h2>

    <p>
      That's a good question. Because we can ?
    </p>

    <figure>
        <img class="medium" src="jurassic-park.jpg" alt="You were so preoccuppied with whether or not you could - you didn't stop to think if you should">
        <figcaption>
            You were so preoccuppied with whether or not you could - you didn't stop to think if you should.
        </figcaption>
      </figure>
  
    <p>
      The original inspiration for this is a project called <a href="https://getnorth2018.com/previous-events/every-thing-every-time/">every thing every time</a> by Naho Matsuda. Her work aims at creating "impractical poetry" from a variety of data streams and sensors across the city: air quality, traffic, shift schedules, mosque prayers, etc. The result is then displayed in real time in the city streets. We've always been totally fascinated by the project, which at the time seemed a refreshing take, slightly impertinent, on the whole "smart cities" schtick.
    </p>

    <p>
      We thought that creating a global version of the same idea would be interesting, not the least because it would allow us to get our hands dirty with OpenStreetMap data. 
    </p>

    <p>
      So in OpenStreetMap Haiku, verses are randomly assembled collecting information about a place, taken from OpenStreetMap. This post goes through the steps involved, which hopefully should help <strong>understand how OSM data works.</strong>
    </p>
      
    <hr />

    <p>
      As they say: “OpenStreetMap is not a map®”. One can rather think about OSM as a gigantic database of all the things in the world. In fact, there is such a thing as a list of all the things in the world, check it out: <a href="https://wiki.openstreetmap.org/wiki/Map_Features">OSM map features</a>.
    </p>
    <p>Hey, this is nothing less than an attempt at methodically <strong>classifying our reality</strong>. So yes, it is a pretty damn long wiki page. You were warned.
    </p>

    <p>
      In OpenStreetMap Haiku, we use that crazy amount of data by matching OSM tags with random verses.<br>
      For example, if a supermarket is close to the map center (an object has a tag <code>shop=supermarket</code>), it would randomly yield one of: <em>"Salad cabbage and carrots"</em>, <em>"The cashier’s bored"</em> or <em>"A lonely aisle"</em> (etc).<br>
      A swimming pool (tag <code>leisure=swimming_pool</code>): ‘Smells of chlorine’.<br>
      A coffee shop named ‘Grey House’ (tags <code>amenity=cafe</code> and <code>name=‘Grey House’</code>: “Fresh coffee from Grey House”.<br>
      And so on.
    </p>

    <p>
      That set of verses is easily extensible - <a href="https://github.com/satellitestudio/osm-haiku/edit/master/app/lines.en.js">have a look and add yours :)</a>. We also take into account the weather and local time of the day, but for now let's focus on the geographical aspect of things: <strong>OpenStreetMap</strong> and the mighty <strong>Overpass</strong>. We'll see how Overpass is our gateway to tap into the incredible richness of OpenStreetMap.
    </p>

    <hr />

    <figure>
      <img class="medium" src="carpet-hanger.png">
      <figcaption>
        Even carpet hangers have their tag
      </figcaption>
    </figure>


    <h2>
      An OpenStreetMap refresher
    </h2>

    <p>
      OpenStreetMap can be a bit overwhelming at first. Not only it's a lot of data, but the software ecosystem that surrounds it is diverse and complex. Might seem obvious, but the best place to start is there: <a href="http://openstreetmap.org">openstreetmap.org</a>.<br>
      Counter-intuitively, openstreetmap.org is not great at being a useful map and doesn't really try to be. It is excellent though, as an entry point and a exploration tool for OpenStreetMap data.
    </p>
  
    <figure>
      <video autoplay loop muted playsinline>
        <source src="query-features.webm" type="video/webm">
      </video>
      <figcaption>Poking at OSM data</figcaption>
    </figure>
  
    <p>
      Using that 'Query features' functionality is pretty much what we'll be programmatically doing to generate haikus. So far, what you see is a bunch of named objects. Looking further, you'll start noticing that these objects have <strong>relationships</strong>: a metro station belongs to a portion of a railway, which itself belongs to an entire metro line:
    </p>

    <figure>
      <video autoplay loop muted playsinline>
        <source src="query-metro.webm" type="video/webm">
      </video>
      <figcaption>A node that belongs to a way that belongs to a relation</figcaption>
    </figure>

    <p>
      And so goes the holy trinity of OpenStreetMap: <strong>Nodes, Ways, Relations</strong>. Typically an object (a metro line, a golf course, a ski resort) can be represented by a <strong>relation</strong>. This relation does not have its own geometry, but rather links to either a bunch of points aka <strong>nodes</strong> (a golf hole) or a bunch of lines aka <strong>ways</strong> (a ski piste), which themselves link to point nodes.
    </p>

    <hr />

    <p>
      Those three basic primitives can each hold an unlimited amount of data. Any number of <strong>tags</strong>, of any form, can be added to any of those three types of objects. See for yourself:
    </p>

    <figure>
      <video autoplay loop muted playsinline>
        <source src="query-features-details.webm" type="video/webm">
      </video>
      <figcaption>Looking for tags</figcaption>
    </figure>

    <p>
      Those tags are always composed of a <code>key=value</code> tuple, and are completely free form: anyone can add any tag they deem useful, there is no schema or spec of any sort. There are <strong>conventions</strong>, though. In general by way of consensus - our carpet hanger tag for example, was <a href="https://wiki.openstreetmap.org/wiki/Tag:man_made%3Dcarpet_hanger">approved by the community at some point</a>. In fact, there is a <a href="https://lists.openstreetmap.org/pipermail/tagging/">dedicated tagging mailing-list</a>, which is a fascinating place, with questions ranging from <a href="https://lists.openstreetmap.org/pipermail/tagging/2018-March/035405.html">tagging fraction house numbers?</a> and <a href="https://lists.openstreetmap.org/pipermail/tagging/2019-July/046358.html">choosing between bbq=yes or barbecue_grill=yes</a> to <em>much</em> more complicated geopolitical issues such as tagging <a href="https://lists.openstreetmap.org/pipermail/talk/2018-October/081553.html">disputed boundaries in Crimea</a>.
    </p>

    <hr />

    <p>
      This is very nice, but how do we programatically access this data? There is such a thing as <a href="https://wiki.openstreetmap.org/wiki/API_v0.6">an OpenStreetMap API</a>. But we should avoid using it for simple read-only scenarios. The OSM API is mostly designed to be used by editing software, a lot of its endpoints are meant for writing, and reading operations are awkward for simple use cases. So here comes our joker:
    </p>

    <h2>
      Overpass, and how to tame it
    </h2>

    <p>
      Overpass is a read-only API to OpenStreetMap, which uses its own query language, <strong><a href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL">Overpass QL</a></strong>, and has its own handy sandbox tool located at <a href="http://overpass-turbo.eu/">overpass-turbo.eu</a>.
    </p>

    <p>
      Overpass is fantastic and weird and powerful and scary. Its query language is very terse, very OSM-specific, very powerful, and can be <em>slightly</em> off-putting, especially for those of us not entirely fluent in <a href="https://en.wikipedia.org/wiki/Malbolge">Malbolge</a>.<br>
      So, young and full of ideals, you set out for <a href="http://overpass-turbo.eu/">overpass-turbo.eu</a>, and, oooh look: it has a friendly "wizard" function. Give it a go with the suggested params. It will generate a query on the left panel, but it's quite hard to tell what's going on. So, not quite the friendly wizard - more like black magic:
    </p>
    <pre>
        <code class="language-js">
            /*
        This has been generated by the overpass-turbo wizard.
        The original search was:
        “amenity=bar”
        */
        [out:json][timeout:25];
        // gather results
        (
          // query part for: “amenity=bar”
          node["amenity"="bar"]({{bbox}});
          way["amenity"="bar"]({{bbox}});
          relation["amenity"="bar"]({{bbox}});
        );
        // print results
        out body;
        >;
        out skel qt;
        </code>
        </pre>


    <hr />

    <p>
      Let's try to decipher Wizard-generated query. Go to <a href="http://overpass-turbo.eu/s/KIp">Overpass Turbo and find the Eiffel Tower, in Paris</a>, and copy paste the following:
    </p>

    <pre>
      <code class="language-js">
        node[natural=tree]({{bbox}});
        out;
      </code>
    </pre>
    
    <p>
      What this means is 'retrieve all the nodes that represent trees (<code>[natural=tree]</code>) in the currently visible map area (<code>({{bbox}})</code>). Then give us the result of that query. Check out the nodes appearing in the map when you click 'Run'. They have extra information such as circumference, height, and even the species of the trees! Now let's look at output options by looking at kebab places:
    </p>
    

    <pre>
      <code class="language-js">
        [out:json];
        node[cuisine=kebab](around:3000,48.8605,2.2957);
        out skel;
      </code>
    </pre>
    
    <p>
      A nicer JSON output now replaced the default XML format (<code>[out:json];</code>), and we've asked for only the geometries, without the tags (<code>out skel;</code>). We also specified a specific area filter, a radius <code>around</code> a point, so the query should look for all kebab places in a 3000 meters radius around the Eiffel Tower <code>(around:3000,48.8605,2.2957)</code>, instead of the `bbox` specified by the frontend. You should see in the map various kebab restaurants around the Eiffel tower such as "Kebab Élysée" (click on the node id to access the full data on osm.org).
    </p>
    <p>
      Now let's explore hierarchical relations with a bus stop/line:
    </p>
    

    <pre>
      <code class="language-js">
          [out:json];
          (
            node["highway"="bus_stop"](around:30,48.8605,2.2957);
          );
          <;
          out body;
      </code>
    </pre>

    <p>
      This does not yield anything visible on the map, but have a look at the data tab, and you'll see an object representing the whole bus line:
    </p>

    <pre>
      <code class="language-json">
          "tags": {
            "colour": "#FFCD01",
            "from": "Gare Saint-Lazare",
            "name": "Bus 42 : Gare Saint-Lazare → Cours de l'Île Seguin",
            "network": "RATP",
            "operator": "RATP",
            "public_transport:version": "2",
            "ref": "42",
            "ref:FR:RATP": "1001000420001",
            "ref:FR:STIF:direction_id": "0",
            "route": "bus",
            "to": "Cours de l'Île Seguin",
            "type": "route",
            "wheelchair": "yes"
          }
      </code>
    </pre>

    <p>
      This happened because we added that instruction: <code><;</code> in our query, which means we want to retrieve all the objects "owning" the selected nodes: in that case, the relationship object representing the bus line, that this bus stop belongs to (<em>recursing up</em>). The next step is to <em>recurse down</em> from that:
    </p>

    <pre>
      <code class="language-js">
          [out:json][timeout:25];
          (
            node["highway"="bus_stop"](around:30,48.8605,2.2957);
          );
          <;
          out body;
          >;
          out body;
      </code>
    </pre>

    <figure>
      <img src="./busline.png" class="medium" />
    </figure>

    <p>
      What happened? From a single bus stop, queried around a point, we queried the parent bus line <strong>relationship</strong>. Then we queried all the bus line "children", which resulted in visible geometries on the map: all the bus line stop nodes/points, as well as the actual itinerary of the bus line as a way/line.
    </p>

    <hr />

    <p>
      Hopefully this should have given you some clues to untangle that wizard-generated query, and more. Here's a useful breakdown:
    </p>

    <figure>
      <img src="wizard.png">
      <figcaption>
        The wizard-generated query, tore apart
      </figcaption>
    </figure>

    <h2>APIs for Haikus</h2>

    <p>
      For OpenStreetMap Haiku we built an Overpass query that tries to answer the question "what's around that point?" (adapted from the query used in osm.org's "Query features" functionality):
    </p>
  

    <pre>
        <code class="language-js">
            const ql = `
              [out:json][timeout:5];

              (
                nwr[~"."~"."](around:${radius},${lat},${lng});
              <;);out tags ${center};

              (
                way[~"landuse|landcover|natural"~"."](around:${radius * 4},${lat},${lng});
              );out tags ${center};

              is_in(${lat},${lng})->.a;
              relation(pivot.a);
              out tags ${center};
            `
        </code>
      </pre>

    <p>
      A few things to note:
    </p>
    <ul>
      <li>it's a template where the clicked point latitude and longitude, and a hardcoded radius are injected;</li>
      <li><code>nwr</code> is a shortcut to query all 3 of node, ways, and relations;</li>
      <li><code>[~"."~"."]</code> will fetch all object that have any key and any value for it's tag, effectively discarding geometries <em>without</em> a tag;</li>
      <li>there's a second query for <code>landuse|landcover|natural</code> tags with 4 times the set radius - the idea being that we want to "look further" for landscape features</li>
    </ul>
    <p>
      Check out <a href="https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL">the Overpass QL reference</a> for specific language elements.
    </p>

    <h2>It's not only about where</h2>

    <p>
      Things get a bit more interesting when we not only look at "here", but also at "now". We're using two additional APIs for that:
    </p>
    <ul>
      <li><a href="https://timezonedb.com/">TimeZoneDB</a> to get local time from a lat/lon pair</li>
      <li><a href="https://openweathermap.org/api">OpenWeatherMap</a> for local weather.</li>
    </ul>

    <p>
      This allows some really cool variations on the base verses, by adding conditions to some of them or injecting extra information in the templates. See for instance:
    </p>
    
    <pre>
      <code class="language-js">
        {
          template: 'Is it too early for a beer?',
          tags: [['amenity', 'pub']],
          condition: (el, env) => env.moment === 'morning'
        }
      </code>
    </pre>

    <pre>
      <code class="language-js">
        {
          template: 'Heat on the paving stones',
          tags: [['surface', 'paving_stones']],
          condition: (el, env) => env.temperature > 20
        },
      </code>
    </pre>

    <h2>But really, why ?</h2>

    <p>
      We think we have created a little window into, maybe not the world, but into the world of OpenStreetMap. OpenStreetMap is a revolutionary project, it's the most complete map of the world ever made. An idea that is usually conveyed by enumerating grand statistics: 5 million users, 5 billion nodes, 3 million changes a day, 100 million distinct tags, etc. We think this can and should also be expressed in a more sensible manner and with a pinch of randomness. Doing what a contributor to OSM does: stop, and look around.
    </p>

    <p>
      It's also always fascinating to see how, with just a few hundreds of very basic building blocks, meaning emerges from chaos, the imagination unravels, narratives materialize...
    </p>

    <cite>
      In the garage where I belong<br>
      Leaving home<br>
      Two children
    </cite>

    <p>
      Let us know what you think: <a href="mailto:contact@satellitestud.io">contact@satellitestud.io</a> or <a href="https://github.com/satellitestudio/osm-haiku/issues/new">create an issue on Github</a>.
    </p>

    <cite>
      The day is young<br>
      The world is big<br>
      Above the freeway noise
    </cite>



  <footer>
    Published <time pubdate datetime="2019-12-10" title="December 10th, 2019">December 10th, 2019</time> by
    <address class="author"><a rel="author" href="http://twitter.com/nerik">Erik</a></address> on <a href="http://satellitestud.io">Satellite Studio</a> blog.
  </footer>

  </article>
  <script src="../../lib/prism.js"></script>
  <script src="../../index.js"></script>
  <script>
    (function() {
        var script = document.createElement('script');
        window.counter = 'https://satellitestudio.goatcounter.com/count'
        script.async = 1;
        script.src = '//gc.zgo.at/count.js';

        var ins = document.getElementsByTagName('script')[0];
        ins.parentNode.insertBefore(script, ins)
    })();
</script>
</body>
</html>
